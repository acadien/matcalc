#!/usr/bin/python

#Takes a dump.dat file, parses it, generates van-hove, fourier transform to
#generate intermediate scattering function

#SHOULD BE RUN ONLY ON NVT/NVE SIMULATIONS WITH UNWRAPPED COORDINATES
#Unwraps outcar coordinates

#mine
import plotRemote as pr
#theirs
import sys
import itertools,random
from scipy import weave
from scipy.weave import converters
from scipy.integrate import simps
from numpy import *
import pylab as pl
#mine
import utils
import parserGens,lammpsIO,outcarIO
from rdf import rdf_periodic

def rdfCriteria(atoms,basis,cr,criteria=None):
    atoms = array(atoms)
    basis = array(basis)
    nTime = atoms.shape[0]
    nAtom = atoms.shape[1]

    nDel=0                      
    ltFlag = False
    if "lt" in criteria:                                                           
        ltFlag=True
    cutoff = float(criteria[2:])
                
    for i,r in enumerate(cr):
        if ltFlag:
            if r>cutoff:
                atoms = delete(atoms,i-nDel,1)
                nAtom -= 1
                nDel += 1
        else:
            if r<cutoff:
                atoms = delete(atoms,i-nDel,1)
                nAtom -= 1
                nDel += 1
    print "nAtom=%d atoms meet criteria %s"%(nAtom,criteria)
    
    nbins = 1000
    rcut = 10.0
    rdf = zeros(nbins)
    for atomTime in atoms:
        rbins,rdist = rdf_periodic(atoms,basis,rcut,nbins)
        rdf += rdist
    rdf /= nTime

    return rbins,rdf

if __name__ == "__main__":
    flags = "Possible Flags\n\
-noPlot: turns off plotting duh\n\
-logt  : turns on log of the time steps\n\
-scale #: the time scale (how much time per step in seconds)\n\
-nStep #: number of steps on the time scale (100 small, 500 big)\
"
    utils.usage(["<dump.dat or OUTCAR>","<criteria>","<ensemble file>"],3,8,flags)
    
    RMAX = 10.0

    #Parse Flags
    plotEnable = True
    logtEnable = False
    scale = None #units in seconds
    nStep = 250
    if "-noPlot" in sys.argv:
        sys.argv.remove("-noPlot")
        plotEnable = False

    #Parse Args
    inputFile = sys.argv[1]
    criteria = sys.argv[2]
    criteFile = sys.argv[3]

    configIterator = parserGens.parseEnsemble(criteFile)
    crTime = array([cr for cr in configIterator][-1])

    criteriaTxt = criteria.replace("gt",">")
    criteriaTxt = criteria.replace("lt","<")

    if scale == None:
        if "OUTCAR" in inputFile:
            scale = 5E-15 #5fs (potim=5)
        else:
            scale = 0.001E-12 #0.001ps (default for units = metal)

    header = "#Generated by %s using file %s\n"%(sys.argv[0].split("/")[-1],inputFile)

    if "OUTCAR" in inputFile:
        ocarFile = inputFile
        atomByteNums = outcarIO.atomBytes(ocarFile)
        nAtom = outcarIO.nAtoms(ocarFile)
        basis = outcarIO.basis(ocarFile)
        
        configIterator = parserGens.parseOutcarAtoms(atomByteNums,ocarFile,nAtom)
        atomsTime = [array(atoms) for atoms in configIterator]
        #atomsTime = unwrap(atomsTime,basis)
    else:
        lmpFile = inputFile
        atomByteNums = lammpsIO.atomsBytes(lmpFile)
        nAtom = lammpsIO.nAtoms(lmpFile)
        basis = lammpsIO.basis(lmpFile)

        configIterator = parserGens.parseLammpsAtoms(atomByteNums,lmpFile,nAtom)
        atomsTime = [array(atoms) for atoms in configIterator]

    if len(crTime)+1 == nAtom:
        crTime=crTime[1:] #chop off the average if necessary

    rvals,rdf = rdfCriteria(atomsTime,basis,crTime,criteria=criteria)

    #Write Data
    outputFile = inputFile + ".rdf" + isfType[0].upper() + "_" + criteria
    odata = header
    for b in range(len(steps)):
        odata += str(steps[b])+" "+str(rdf[b])+"\n"
    open(outputFile,"w").write(odata)

    #Plotting
    pl.plot(steps,rdf)
    
    pl.title("Radial Distribution Function %s"%criteFile + criteria)
    pl.xlabel("r$(\AA)$")
    pl.ylabel("g(r)")
        
    if plotEnable:
        pr.prshow()
