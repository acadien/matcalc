#!/usr/bin/python

#Calculates the ISF-self per atom and dumps it to file

import sys
import itertools,random
from scipy import weave
from scipy.weave import converters
from scipy.integrate import simps
from numpy import array,zeros,pi,log10,cos,sin,sqrt
#mine
import utils
import parserGens,lammpsIO,outcarIO
from rootMeanSquareDist import unwrap
from vanHove import vanHoveSelf


ISFSelfEnsembleSphereRefCode = """
double *qxs,*qys,*qzs,a,b,a2,b2,qx,qy,qz;
qxs = (double*)malloc(sizeof(double)*(int)nqVecs);
qys = (double*)malloc(sizeof(double)*(int)nqVecs);
qzs = (double*)malloc(sizeof(double)*(int)nqVecs);
int qlen=0;
while( qlen < nqVecs ){
    a = rand()*2/(double)RAND_MAX-1.0;
    b = rand()*2/(double)RAND_MAX-1.0;
    a2 = a*a;
    b2 = b*b;

    if(a2 + b2 > 1.0) 
        continue;

    qxs[qlen] = (2*a*sqrt(1-a2-b2))*q;
    qys[qlen] = (2*b*sqrt(1-a2-b2))*q;
    qzs[qlen] = (1-2*(a2+b2))*q;

    qlen++;
}

double c,d,dx,dy,dz;
double *seta,*setb;
double norm = 1.0/nTime/nqVecs;
int stepSize;
for(int s=0; s<nStep; s++){ //loop over step size
  stepSize = steps[s];
  
  c=0.0;
  for(int t=0; t<nTime-stepSize; t++){ //loop over time steps
    for(int q=0;q<nqVecs;q++){
      qx = qxs[q];
      qy = qys[q];
      qz = qzs[q];

      seta=&(atoms[(int)(t*nAtom*3)]);
      setb=&(atoms[(int)((t+stepSize)*nAtom*3)]);

      for(int i=0; i<nAtom; i++){ //loop over atoms
      
        dx = setb[i*3+0] - seta[i*3+0];
        dy = setb[i*3+1] - seta[i*3+1];
        dz = setb[i*3+2] - seta[i*3+2];

        isfsen[s*nAtom+i] += cos(dx*qx + dy*qy + dz*qz);
  }}}
  for( int i=0; i<nAtom; i++)
    isfsen[s*nAtom+i] *= norm;
}
"""

def ISFSelfEnsemble(atoms,basis,steps=None,nqVecs=1,qmax=3.32,nStep=250):#qmax (first peak=1.9, second peak=3.32)
    atoms = array(atoms)
    basis = array(basis)
    nTime = atoms.shape[0]
    nAtom = atoms.shape[1]

    if steps == None:
        if linEnable:
            nStep = 1000
            steps = map(float,range(nStep))
        else:
            steps = sorted(list(set(array([int(10**(t*10.0/nStep-1.0)) for t in range(nStep)]))))
            steps.remove(0)
            steps = [t for t in steps if t<nTime]
            steps = array(steps)
            nStep = len(steps)
    atoms = atoms.ravel()

    isfsen = zeros([nStep,nAtom]).ravel()
    q=qmax

    weave.inline(ISFSelfEnsembleSphereRefCode,['nqVecs','steps','nStep','isfsen','atoms','nTime','nAtom','q'])
    isfsen.shape = [nStep,nAtom]
    return steps,isfsen

if __name__ == "__main__":
    flags = "Possible Flags\n\
-logt  : turns on log of the time steps\n\
-scale #: the time scale (how much time per step in seconds)\n\
-nStep #: number of steps on the time scale (100 small, 500 big)\n\
-nqVec #: the number of random qvectors to generate and average over\
"
    utils.usage(["<dump.dat or OUTCAR>"],1,6,flags)
    

    RMAX = 10.0

    logtEnable = False
    linEnable = False
    scale = None #units in seconds
    nStep = 250
    nqVecs = 5
    if "-logt" in sys.argv:
        sys.argv.remove("-logt")
        logtEnable = True
    if "-scale" in sys.argv:
        i = sys.argv.index("-scale")
        scale = float(sys.argv[i+1])
        sys.argv.pop(i)
        sys.argv.pop(i)
    if "-nStep" in sys.argv:
        i = sys.argv.index("-nStep")
        nStep = int(sys.argv[i+1])
        sys.argv.pop(i)
        sys.argv.pop(i)
    if "-linear" in sys.argv:
        linEnable = True
        i = sys.argv.index("-linear")
        sys.argv.pop(i)
    if "-nqVecs" in sys.argv:
        i = sys.argv.index("-nqVecs")
        nqVecs = int(sys.argv[i+1])
        sys.argv.pop(i)
        sys.argv.pop(i)

    inputFile = sys.argv[1]

    if scale == None:
        if "OUTCAR" in inputFile:
            scale = 5E-15 #5fs (potim=5)
        else:
            scale = 0.001E-12 #0.001ps (default for units = metal)

    if logtEnable:
        header = "#Generated by %s using file %s\n#log(t) ISF \n"%(sys.argv[0].split("/")[-1],inputFile)
    else:
        header = "#Generated by %s using file %s\n#t(ps) ISF \n"%(sys.argv[0].split("/"),inputFile)

    if "OUTCAR" in inputFile:
        ocarFile = inputFile
        atomByteNums = outcarIO.atomBytes(ocarFile)
        nAtom = outcarIO.nAtoms(ocarFile)
        basis = outcarIO.basis(ocarFile)
        
        configIterator = parserGens.parseOutcarAtoms(atomByteNums,ocarFile,nAtom)
        atomsTime = [array(atoms) for atoms in configIterator]
        atomsTime = unwrap(atomsTime,basis)
    else:
        lmpFile = inputFile
        atomByteNums = lammpsIO.atomsBytes(lmpFile)
        nAtom = lammpsIO.nAtoms(lmpFile)
        basis = lammpsIO.basis(lmpFile)
        bounds=[[0,basis[0][0]],[0,basis[1][1]],[0,basis[2][2]]]

        configIterator = parserGens.parseLammpsAtoms(atomByteNums,lmpFile,nAtom)
        atomsTime = [array(atoms) for atoms in configIterator]

    steps,isfsen = ISFSelfEnsemble(atomsTime,basis,nqVecs=nqVecs,nStep=nStep)
    ylab = "$F_S(q,t)$"

    scale /= 1E-12 #picosecond conversion
    steps = [i*scale for i in steps]
    
    if logtEnable:
        steps=log10(steps)
    
    outputFile = inputFile + ".isfSEnsemble" 
    if linEnable:
        outputFile += "_lin"

    odata = header
    for b in range(len(steps)):
        odata += str(steps[b])+" "+" ".join(map(str,isfsen[b]))+"\n"
    open(outputFile,"w").write(odata)

    print "Wrote %s ."%outputFile
