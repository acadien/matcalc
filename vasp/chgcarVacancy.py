#!/usr/bin/python

#Reads from the CHGCAR_sum generated by the sumchg.pl script
#Given some eV cutoff counts the number of charge cells that are *above* 
#that density and spits out the density as   #cells > chg / total # cells

import sys,operator,os
import pickle
from numpy import *
from matplotlib import ticker
from matplotlib import pyplot as P
import pylab as pl
#mine
from poscarIO import readposcar

def usage():
    print "Usage:"
    print "%s <chgfile> <charge cutoff (eV)> <plotting style: 0,1,2>"%sys.argv[0]
    print "Plotting Styles: 0=none, 1=chg contours, 2=vacancy contours"
    exit(0)

if not(len(sys.argv) in [3,4]):
    usage()

chgcar = open(sys.argv[1],"r").readlines()
cutev = float(sys.argv[2])
pstyle = int(sys.argv[3])

v1,v2,v3,types,xs,ys,zs,header,chgcar = readposcar(chgcar)
chgcar.pop(0)
gridsz=[int(i) for i in chgcar.pop(0).split()]
Tot_pnts = reduce(operator.mul,gridsz)

vol=dot(v1,cross(v2,v3))/Tot_pnts

global dataset
dataset=list()
for line in chgcar:
    dataset+=[float(i)*vol for i in line.split()]
dataset=dataset[:Tot_pnts] #chop off extra, invalid values
def clearoutlier(i): return 300.0 if i>300.0 else i

#dataset is 1d
dhist=pl.hist(dataset,bins=10000,range=(0,1000),normed=True,histtype='step')[0]
f=open("CHGDENS_HIST","w")
pickle.dump(dhist,f)
f.close()

#Convert the dataset from charge density to vacancy
def vval(a,b): return 1 if a<b else 0
vacData=[vval(i,cutev) for i in dataset]
nvacays=sum(vacData)

#Convert dataset to 3d array
if pstyle==1:
    dataset=[clearoutlier(i) for i in dataset]
    dataset=array(dataset).reshape(gridsz) #[x,y,z]
elif pstyle==2:
    dataset=array(vacData).reshape(gridsz) #[x,y,z]

print "%d Points out of %d Total."%(nvacays,Tot_pnts)
print "%3.3f%% Vacant"%(nvacays*100.0/Tot_pnts)

x=linspace(0,19,gridsz[0])
y=linspace(0,19,gridsz[1])
X,Y = meshgrid(x,y)

def logplotter(X,Y,z,ticks,colors):
    P.cla()
    P.contourf(X,Y,z,ticks,colors=colors)#,locator=ticker.LogLocator())

def plotter(X,Y,z):
    P.cla()
    P.contourf(X,Y,z)

def keypress(event):
    global pos,fig,dataset,ticks,colors
    if event.key==",":
        pos -= 1
    if event.key==".":
        pos += 10
    pos=pos%gridsz[0]
    if pstyle==1:
        logplotter(X,Y,dataset[pos,:,:],ticks,colors)
        pl.title("%d Log plot energy density, use < and > to change plots"%pos)
    elif pstyle==2:
        plotter(X,Y,dataset[pos,:,:])
        pl.title("%d Vacancy in Red, use < and > to change plots"%pos)
    pl.draw()
        
def float2rgb(val, cmin, cmax):
    x = float(val-cmin)/float(cmax-cmin)
    r = min(max(4*fabs(x-0.5)-1., 0.), 1.)
    g = min(max(4*(x-0.25), 0.), 1.)
    b = min(max(4*(0.75-x), 0.), 1.)
    return (r,g,b)

global fig,pos,ticks,colors
ticks=[1e-3,0.5,1.0,1.5,2.0,2.5,3.0,3.5,4.0,4.5,5.0,6.0,7.0,8.0,9.0,10.0,15.0,20.0,25.0,30.0,50.0,70.0,100.0,300.0]
mxc=sqrt(len(ticks)+1)
mic=0
colors=[float2rgb(sqrt(i+1),mic,mxc) for i in range(len(ticks))]

pl.plot([cutev,cutev],[0,0.5],c="black",lw=3.0)
pl.xlim(0,10)
pl.xlabel("Charge (eV)")
pl.ylabel("Count")
pl.title("Histogram of Charge Density %s"%os.getcwd().split("/")[-1])

if pstyle!=0:
    fig=pl.figure()
    canvas=fig.canvas
    pos=0

    
    canvas.mpl_connect("key_press_event",keypress)
    if pstyle==1:
        logplotter(X,Y,dataset[pos,:,:],ticks,colors)
        pl.title("%d Log plot energy density, use < and > to change plots"%pos)
        P.colorbar(ticks=ticks,drawedges=True)
    elif pstyle==2:
        plotter(X,Y,dataset[pos,:,:])
        pl.title("%d Vacancy in Red, use < and > to change plots"%pos)
P.show()



