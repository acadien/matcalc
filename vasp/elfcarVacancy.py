#!/usr/bin/python

#Reads from the CHGCAR_sum generated by the sumchg.pl script
#Given some eV cutoff counts the number of charge cells that are *above* 
#that density and spits out the density as   #cells > chg / total # cells

import sys,operator,os
import pickle
from numpy import *
from matplotlib import ticker
import matplotlib
#matplotlib.use('Agg') 
from matplotlib import pyplot as P
import pylab as pl
import subprocess
#mine
from poscarIO import readposcar

def usage():
    print "Usage:"
    print "%s <elfcarfile> <charge cutoff (eV)> <plotting style: 0,1,2,3,4,5>"%sys.argv[0]
    print "Plotting Styles: 0=none, 1=chg contours, 2=vacancy contours, 3=make a bunch of plots for a movie,\n4=chg contours with atoms, 5=make a bunch of plots for a movie with spheres"
    exit(0)

if not(len(sys.argv) in [3,4]):
    usage()

elfcar = open(sys.argv[1],"r").readlines()
cutev = float(sys.argv[2])
pstyle = int(sys.argv[3])

v1,v2,v3,types,cxs,cys,czs,header,elfcar = readposcar(elfcar)

elfcar.pop(0)
gridsz=[int(i) for i in elfcar.pop(0).split()]
Tot_pnts = reduce(operator.mul,gridsz)

global dataset
dataset=list()
for line in elfcar:
    dataset+=[float(i) for i in line.split()]
dataset=dataset[:Tot_pnts] #chop off extra, invalid values

#Convert the dataset from charge density to vacancy
def vval(a,b): return 1 if a<b else 0
vacData=[vval(i,cutev) for i in dataset]
nvacays=sum(vacData)

#Convert dataset to 3d array
if pstyle not in [2]:
    dataset=array(dataset).reshape(gridsz) #[x,y,z]
elif pstyle==2:
    dataset=array(vacData).reshape(gridsz) #[x,y,z]

print "%d Points out of %d Total."%(nvacays,Tot_pnts)
print "%3.3f%% Vacant"%(nvacays*100.0/Tot_pnts)

#lratio=1.0/v1[0] #Used to convert sphere radius to plot size (1x1x1)
global atoms,atomcolors,atombounds
#Ge: 1.22 
#Sb: 1.4
#Te: 1.4
#Au: 1.35
#Cu: 1.4
#Ce: 1.8
radii=[1.8,1.39,1.4]
acolors=[(0.1,0.1,0.1),(0.5,0.5,0.5),(0.9,0.9,0.9)]
atomradii=list()
atomcolors=list()
for i in range(len(types)):
    t=types[i]
    atomradii+=[radii[i]]*t
    atomcolors+=[acolors[i]]*t
atoms=zip(cxs,cys,czs,atomradii)
atombounds=array([[zpos-r,zpos+r] for zpos,r in zip(czs,atomradii)])

x=linspace(0,v1[0],gridsz[0])
y=linspace(0,v2[1],gridsz[1])
global zsize
zsize=v3[2]
X,Y = meshgrid(x,y)

def plotspheres(zpos,atombounds,atoms,atomcolors):
    for i,bounds in enumerate(atombounds):
        cirs=list()
        if (zpos > bounds[0] and zpos < bounds[1]) or zpos < bounds[1]-v3[2] or zpos > bounds[0]+v3[2]:
            x=atoms[i][0]
            y=atoms[i][1]
            z=atoms[i][2]
            
            d=z-zpos
            if bounds[0] < 0 and zpos>v3[2]/2:
                d+=v3[2]
            elif bounds[1] > v3[2] and zpos<v3[2]/2:
                d-=v3[2]
            r=sqrt(atoms[i][3]**2-d**2)

            #print zpos,bounds,"in",r
            cirs.append( pl.Circle((x,y), radius=r, fc='None' , color=atomcolors[i]) )

            if x+r > v1[0]:
                cirs.append( pl.Circle((x-v1[0],y), radius=r, fc='None' , color=atomcolors[i]))
            if x-r < 0:
                cirs.append(pl.Circle((x+v1[0],y), radius=r, fc='None' , color=atomcolors[i]))
            if y+r > v2[1]:
                cirs.append(pl.Circle((x,y-v2[1]), radius=r, fc='None' , color=atomcolors[i]))
            if y-r < 0:
                cirs.append(pl.Circle((x,y+v2[1]), radius=r, fc='None' , color=atomcolors[i]))

            if x+r > v1[0] and y+r > v2[1]:
                cirs.append( pl.Circle((x-v1[0],y-v2[1]), radius=r, fc='None' , color=atomcolors[i]))
            if x+r > v1[0] and y-r < 0:
                cirs.append(pl.Circle((x-v1[0],y+v2[1]), radius=r, fc='None' , color=atomcolors[i]))
            if x-r < 0 and y+r > v2[1]:
                cirs.append(pl.Circle((x+v1[0],y-v2[1]), radius=r, fc='None' , color=atomcolors[i]))
            if x-r < 0 and y-r < 0:
                cirs.append(pl.Circle((x+v1[0],y+v2[1]), radius=r, fc='None' , color=atomcolors[i]))


            for cir in cirs:
                pl.gca().add_patch(cir)
        #else:
        #    print zpos,bounds,"out"
    #exit(0)

    #pylab.axis('scaled')

def image_spheres(bounds,z,pos,atombounds,atoms,atomcolors):
    pl.cla()
    plotspheres(pos,atombounds,atoms,atomcolors)

    pl.imshow(flipud(z),extent=bounds,vmin=0,vmax=1)


def logplotter_spheres(X,Y,z,ticks,colors,pos,atombounds,atoms,atomcolors):
    pl.cla()
    pl.contourf(X,Y,z,ticks,colors=colors,locator=ticker.LogLocator())
    #pl.contour(X,Y,z,ticks,colors=colors)#,locator=ticker.LogLocator())
    plotspheres(pos,atombounds,atoms,atomcolors)
    pl.tick_params(axis='both',bottom='off',left='off',labelbottom='off',labelleft='off',right='off',top='off')

def logplotter(X,Y,z,ticks,colors):
    pl.cla()
    pl.contourf(X,Y,z,ticks,colors=colors,locator=ticker.LogLocator())
    pl.contour(X,Y,z,ticks,colors=colors)#,locator=ticker.LogLocator())
    pl.tick_params(axis='both',bottom='off',left='off',labelbottom='off',labelleft='off',right='off',top='off')

def plotter(X,Y,z):
    pl.cla()
    pl.contourf(X,Y,z)

def keypress(event):
    global pos,fig,dataset,ticks,colors,atombounds,atoms,atomcolors,zsize
    if event.key==",":
        pos -= 1
    if event.key==".":
        pos += 10
    pos=pos%gridsz[0]
    if pstyle==1:
        logplotter(X,Y,dataset[pos,:,:],ticks,colors)
        pl.title("%d Log plot energy density, use < and > to change plots"%pos)
    elif pstyle==2:
        plotter(X,Y,dataset[pos,:,:])
        pl.title("%d Vacancy in Red, use < and > to change plots"%pos)
    elif pstyle==4:
        logplotter_spheres(X,Y,dataset[pos,:,:],ticks,colors,pos*zsize/gridsz[0],atombounds,atoms,atomcolors)
        pl.title("%d Log plot ELF, use < and > to change plots"%pos)
    elif pstyle==6:
        image_spheres([0,v1[0],0,v2[1]],dataset[pos,:,:],pos*zsize/gridsz[0],atombounds,atoms,atomcolors)
        pl.title("%d ELF, use < and > to change plots"%pos)
    pl.draw()
        
def float2rgb(val, cmin, cmax):
    x = float(val-cmin)/float(cmax-cmin)
    r = min(max(4*fabs(x-0.5)-1., 0.), 1.)
    g = min(max(4*(x-0.25), 0.), 1.)
    b = min(max(4*(0.75-x), 0.), 1.)
    return (r,g,b)

global fig,pos,ticks,colors
ticks=[float(i)/10 for i in range(10)]#20
mxc=sqrt(len(ticks)+1)
mic=0
colors=[float2rgb(sqrt(i+1),mic,mxc) for i in range(len(ticks))]
print atombounds
#pl.plot([cutev,cutev],[0,0.5],c="black",lw=3.0)
#pl.xlabel("Electron Localization Function")
#pl.ylabel("Count")
#pl.title("Histogram of Charge Density %s"%os.getcwd().split("/")[-1])
#pl.show()
if pstyle!=0:
    fig=pl.figure()
    canvas=fig.canvas
    pos=0

    
    canvas.mpl_connect("key_press_event",keypress)
    if pstyle==1:
        logplotter(X,Y,dataset[pos,:,:],ticks,colors)
        pl.title("%d Log plot ELF, use < and > to change plots"%pos)
        pl.colorbar(ticks=ticks,drawedges=True)
    elif pstyle==2:
        plotter(X,Y,dataset[pos,:,:])
        pl.title("%d Vacancy in Red, use < and > to change plots"%pos)
    elif pstyle==3:
        for i in range(gridsz[0]):
            logplotter(X,Y,dataset[i,:,:],ticks,colors)
            if i==0:
                pl.colorbar(ticks=ticks,drawedges=True)
            pl.title("Electron Localization of Ge$_2$Sb$_2$Te$_5$ Amorphous Structure")
            for p in range(2):
                pl.savefig("elfplot%3.3d.png"%(i*2+p))
    elif pstyle==4:
        logplotter_spheres(X,Y,dataset[pos,:,:],ticks,colors,pos*zsize/gridsz[0],atombounds,atoms,atomcolors)
        pl.colorbar(ticks=ticks,drawedges=True)
        pl.title("%d Log plot ELF, use < and > to change plots"%pos)
    elif pstyle==5:
        for i in range(gridsz[0]):
            logplotter_spheres(X,Y,dataset[i,:,:],ticks,colors,i*zsize/gridsz[0],atombounds,atoms,atomcolors)
            if i==0:
                pl.colorbar(ticks=ticks,drawedges=True)
            pl.title("Electron Localization of Ge$_2$Sb$_2$Te$_5$ Amorphous Structure")
            for p in range(2):
                pl.savefig("elfplot%3.3d.png"%(i*2+p))
    elif pstyle==6:
        print len(dataset)
        image_spheres([0,v1[0],0,v2[1]],dataset[i,:,:],i*zsize/gridsz[0],atombounds,atoms,atomcolors)
        pl.title("%d ELF, use < and > to change plots"%pos)
        P.colorbar()
pl.show()




